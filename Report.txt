Name: Fidel A. Molina

Number of elements:10000

Bubble Sort
Sorted:2.60914 seconds
Reversed:5.70683 seconds
Random:4.60962 seconds

Bubble Sort Early Exit
Sorted:0.00056 seconds
Reversed:6.08003 seconds
Random:4.37910 seconds

Selection Sort
Sorted:2.20690 seconds
Reversed:2.20241 seconds
Random:2.08184 seconds

Insertion Sort
Sorted:0.00099 seconds
Reversed:4.62838 seconds
Random:2.34769 seconds

Merge Sort
Sorted:0.01625 seconds
Reversed:0.02482 seconds
Random:0.02751 seconds

Questions to answer:
1) What was the worst case scenario for any sorting technique?
    Bubble sort Reversed was the worst case scenario with 6.08003 seconds

2) The first 3 sorts have the same runtime of O(n^2). Why were the times different? Why would one be more efficient than the others?
    Even though Bubble Sort, Selection Sort, and Insertion Sort are all O(n²), their times were different because they do different numbers of swaps and memory operations.
    Selection Sort is usually faster because it only swaps once per pass. Insertion Sort is very fast for nearly sorted lists. Bubble Sort is usually the slowest because it makes many unnecessary swaps.

3) Why was merge sort so much more efficient?
    Merge sort was much more efficient because it uses an algorithm with a runtime of O(n log n) instead of O(n²). 
    This means that as the number of elements increases, the amount of work grows much more slowly compared to the other sorts.
    Instead of repeatedly comparing every element to every other element, merge sort splits the list into smaller parts, sorts them efficiently, and then merges them back together.

4) The built-in sorting technique for most programming languages is known as TimSort.
This is a merge sort until the arrays have fewer than 10 elements, then it does an insertion sort. Why would this be useful?
    TimSort is useful because it combines merge sort and insertion sort into one powerful algorithm. 
    Merge sort is very fast for large lists, while insertion sort is extremely fast for small or nearly sorted lists. 

5) What issues can you see with a recursive sorting technique like merge sort?
    One issue with recursive sorting techniques like merge sort is that they require extra memory to store temporary arrays while merging, which can be a problem for very large datasets. 
    Another issue is the risk of stack overflow. Stack overflow happens when a recursive function calls itself too many times and uses up all the memory meant to keep track of those calls, causing the program to crash.